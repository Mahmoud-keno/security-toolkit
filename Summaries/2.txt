، 3 RSA (Rivest-Shamir-Adleman)


Reference:
Original 1978 MIT paper, ACM Communications, Vol 21, Issue 2

Historical Breakthrough:

* First practical public-key system
* Revolutionized secure communications
* Enabled e-commerce and digital signatures

Mathematical Foundation:
Security Basis: Integer Factorization Problem

* Easy: Multiply two large primes (p × q = n)
* Hard: Given n, find p and q
* Example: 3072-bit RSA uses 1536-bit primes

  * Product: Easy to compute
  * Factorization: Believed to take billions of years

Detailed Algorithm:

Key Generation (Step-by-Step):

1. Choose two large primes p and q
   Requirements:

* Randomly generated
* Should not be close together
* Typically 1024+ bits each today

2. Compute n = p × q

* This is the modulus
* Publicly known
* Determines key strength

3. Compute φ(n) = (p-1)(q-1)

* Euler's totient function
* MUST be kept secret

4. Choose e (public exponent):
   Conditions:

* 1 < e < φ(n)
* gcd(e, φ(n)) = 1
  Common choices: 3, 17, 65537 (2¹⁶ + 1)
  Why 65537? Binary: 10000000000000001
  Only two 1's, efficient exponentiation

5. Compute d (private exponent):
   d ≡ e⁻¹ mod φ(n)
   Using Extended Euclidean Algorithm

Encryption/Decryption Process:

Encryption (by anyone): c ≡ mᵉ mod n
Decryption (private key): m ≡ cᵈ mod n

Where:
m = message (as integer)
c = ciphertext
e,n = public key
d,n = private key

Optimization: Chinese Remainder Theorem (CRT):

* Used for faster decryption
* Works with p and q separately
* About 4× faster than standard method

Strengths of RSA:

1. Conceptually Simple: Easy to understand
2. Versatile: Encryption, signatures, key exchange
3. Well-Studied: 40+ years of analysis
4. Standardized: PKCS#1, RFC 8017
5. Patent Expired: Free to use since 2000

Weaknesses & Attacks:

1. Slow: 1000× slower than symmetric crypto
2. Large Keys: 2048-bit minimum today (vs 256-bit AES)
3. Padding Critical: Raw RSA is insecure

* Must use OAEP (Optimal Asymmetric Encryption Padding)
* Without padding: vulnerable to many attacks

4. Implementation Pitfalls:

* Timing Attacks: Measure decryption time
* Padding Oracle Attacks: Error messages leak info
* Side-Channel Attacks: Power analysis, EM radiation

5. Quantum Threat: Shor's algorithm can break RSA

* Currently requires quantum computer
* Post-quantum crypto being developed

Common Vulnerabilities in Learning Implementations:

1. Small Primes: Demonstration uses small primes, real uses 1024+
2. No Padding: Educational code often omits critical padding
3. ASCII Only: Real systems handle binary data
4. Textbook RSA: Insecure - only for learning

Real-World Usage:

1. SSL/TLS: RSA for key exchange (being replaced by ECDHE)
2. Digital Signatures: RSA-PSS (Probabilistic Signature Scheme)
3. Software Distribution: Code signing certificates
4. Email Encryption: PGP/GPG uses RSA

Key Size Recommendations Over Time:

Year    Key Size    Security Level
1990    512 bits    Broken in 1999 (464-bit factored)
2000    1024 bits   Minimum until 2010
2010    2048 bits   Current minimum
2020    3072 bits   Recommended for new systems
2030+   4096 bits   Future proofing

Why RSA Remains Important:

1. Educational: Best intro to public-key crypto
2. Historical: First successful implementation
3. Foundation: Concepts used in newer algorithms
4. Ubiquitous: Still widely deployed

---

4. Diffie-Hellman Key Exchange

Reference:
1976 paper "New Directions in Cryptography" - Foundation of public-key cryptography

The Big Idea: Secure key exchange without prior shared secret

Mathematical Basis: Discrete Logarithm Problem

Given: g, p, and gᵃ mod p
Find: a (the exponent)

Easy: Compute gᵃ mod p (modular exponentiation)
Hard: Given gᵃ mod p, find a (discrete logarithm)

Protocol Steps (Detailed):

Setup Phase:

1. Choose large prime p (typically 2048+ bits)
2. Choose generator g of the multiplicative group modulo p
   Conditions:

* g is primitive root modulo p
* g^q mod p ≠ 1 for all q divisors of p-1

Key Exchange:

Alice (private key a)        Bob (private key b)
Choose random a             Choose random b
Compute A = gᵃ mod p        Compute B = gᵇ mod p
Send A to Bob               Send B to Alice
Receive B from Bob          Receive A from Alice
Compute s = Bᵃ mod p        Compute s = Aᵇ mod p
Both get s = gᵃᵇ mod p

Why It Works:

1. Commutativity: (gᵃ)ᵇ = (gᵇ)ᵃ = gᵃᵇ
2. One-Way Function: Easy to compute gᵃ mod p, hard to find a
3. Forward Secrecy: Each session uses new random a,b

Security Considerations:

Parameter Selection Critical:

1. Prime p must be "safe prime": p = 2q + 1 where q is also prime
2. Generator g typically 2 or 5: Small, efficient
3. Private keys must be random: Cryptographically secure random numbers

Known Groups (Standardized):

* RFC 7919: Finite Field Diffie-Hellman groups
* Group 14: 2048-bit MODP group (common)
* Group 15: 3072-bit
* Group 16: 4096-bit

Strengths:

1. Perfect Forward Secrecy: Each session independent
2. No Authentication Needed in Basic Form: Just key exchange
3. Efficient: One modular exponentiation each side
4. Standardized: IKE, TLS, SSH, IPsec use DH

Weaknesses:

1. Man-in-the-Middle (MITM) Attack
   Solution: Authentication (digital signatures)

2. Logjam Attack (2015):

* Forces downgrade to 512-bit export-grade DH
* Solution: Use 2048+ bit primes, disable export ciphers

3. Implementation Issues:

* Weak random number generators
* Reusing private keys (breaks forward secrecy)
* Small subgroup confinement attacks

Ephemeral vs Static DH:

* Ephemeral DH (DHE): New key for each session (PFS)
* Static DH: Same key reused (no PFS but faster)

Elliptic Curve DH (ECDH):

* Same concept, different mathematics
* Uses elliptic curves instead of modular arithmetic
* Smaller keys: 256-bit ECDH ≈ 3072-bit DH
* More efficient, becoming standard

Real-World Usage:

1. TLS: DHE or ECDHE cipher suites
2. SSH: Diffie-Hellman key exchange
3. IPsec/IKE: Phase 1 key establishment
4. Signal Protocol: Triple Diffie-Hellman (X3DH)

Why DH is Revolutionary:

1. First Solution to key distribution problem
2. Enabled public-key cryptography
3. Foundation for modern secure protocols
4. Still Relevant 45+ years later


